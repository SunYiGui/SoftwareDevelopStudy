## Start

#### 新建springboot项目、引入对应的依赖（web、mybatis、mysql驱动）

在`pom.xml`文件中导入对应依赖：

```xml
	<dependencies>
<!--        web依赖-->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-web</artifactId>
		</dependency>
<!--测试单元-->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-test</artifactId>
			<scope>test</scope>
		</dependency>
<!--		mybatis依赖-->
		<dependency>
			<groupId>org.mybatis.spring.boot</groupId>
			<artifactId>mybatis-spring-boot-starter</artifactId>
			<version>3.0.0</version>
		</dependency>
<!--		mysql依赖-->
		<dependency>
			<groupId>com.mysql</groupId>
			<artifactId>mysql-connector-j</artifactId>

		</dependency>

	</dependencies>
```

#### 配置文件application.yml中引入mybatis的配置信息

```yml
#配置mybatis
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/big_event
    username: root
    password: 123456
```

#### 创建包结构，准备实体类



## 用户模块

开发模块流程：

![](../../../img/微信截图_20241015163355.png)



#### 注册

**基本信息：**

请求路径：/user/register

请求方式：POST

接口描述：该接口用于注册新用户

**请求参数：**

请求参数格式：x-www-form-urlencoded

请求参数说明：

| 参数名称 | 说明   | 类型   | 是否必须 | 备注           |
| -------- | ------ | ------ | -------- | -------------- |
| username | 用户名 | string | 是       | 5-16位非空字符 |
| password | 密码   | string | 是       | 5-16位非空字符 |

请求数据样例：

```shell
username=zhangsan&password=123456
```

**响应数据：**

响应数据类型：application/json

响应参数说明：

| 名称    | 类型   | 是否必须 | 默认值 | 备注                   | 其他信息 |
| ------- | ------ | -------- | ------ | ---------------------- | -------- |
| code    | number | 必须     |        | 响应码，0-成功，1-失败 |          |
| message | string | 非必须   |        | 提示信息               |          |
| data    | object | 非必须   |        | 返回的数据             |          |

响应数据样例：

```json
{
    "code":0,
    "meddage":"操作成功",
    "data":null
}
```

注入原理？？

后端测试：postMan

```text
406问题，No acceptable representation

实体类没有set,get方法
```

##### **参数校验框架：**Spring Validation

Spring提供一个参数校验框架，使用预定义的注解完成参数校验

###### 1、引入Spring Validataon起步依赖

```xml
<!--		validation依赖-->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-validation</artifactId>
		</dependency>
```

###### 2、在参数前面添加@Pattern注解



###### 3、在Controller类上添加@Validated注解

###### 4、参数校验失败异常处理

在全局异常处理器中，处理异常返回结果

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    @ExceptionHandler(Exception.class)//表明处理的是Exception异常
    public Result handleException(final Exception e) {
        e.printStackTrace();
        return Result.error(StringUtils.hasLength(e.getMessage())?e.getMessage():"操作失败" );
    }
}
```

`@RestControllerAdvice`是 Spring 框架中的一个注解，用于定义全局的异常处理、统一的响应处理等功能。

#### 登录

##### 基本信息

请求路径：/user/login

请求方式：POST

接口描述：该接口用于登录

##### 请求参数

请求参数格式：x-www-form-urlencoded

请求参数说明：

| 参数名称 | 说明   | 类型   | 是否必须 | 备注           |
| -------- | ------ | ------ | -------- | -------------- |
| username | 用户名 | String | 是       | 5-16位非空字符 |
| password | 密码   |        | String是 | 5-16位非空字符 |

请求数据样例：

```shell
username=zhangsan&password=123456
```

##### 响应数据

响应数据类型：application/json

响应参数说明：

响应参数说明：

| 名称    | 类型   | 是否必须 | 默认值 | 备注                   | 其他信息 |
| ------- | ------ | -------- | ------ | ---------------------- | -------- |
| code    | number | 必须     |        | 响应码，0-成功，1-失败 |          |
| message | string | 非必须   |        | 提示信息               |          |
| data    | string | 必须     |        | 返回的数据，jwt令牌    |          |

响应数据样例：

```json
{
"code":0
"message":“操作成功"
"data":
"eyhtGci0JIUzIINISInR5cCI6IkpXVc9.eyJjbGFpbXMionsiawQiojUsInVz2XJuYW11Tjoid2FuZ2JhInOSIMV4CCI6MTYSMZCXNTK30HO,PE_RATCOF7NMSKED9eC3CZCBbKWAFOLOISUMNinZ95M"
}
```

##### 备注

用户登录成功后，系统会自动下发JWT令牌，然后再后续的每次请求中，浏览器都需要再请求头header中携带到服务端，请求头的名称位Authorizaton，值为登录时下发的JWT令牌。

如果检测到用户未登录，则http响应状态码为401

##### 登录认证（JWT）

令牌就是一段字符串

承载业务数据，减少后于请求查询数据库的次数

防篡改，保证信息的合法和有效性

**JWT 的结构**

JWT 由三部分组成，分别用句号（.）分隔：

1. 头部（Header）：通常包含两部分信息，令牌的类型（即 “JWT”）和使用的哈希算法（如 HMAC SHA256 或 RSA）。例如：`{ "alg": "HS256", "typ": "JWT" }`。这个部分会被 Base64Url 编码。
2. 载荷（Payload）：包含声明（claims），声明是关于实体（通常为用户）和其他额外数据的声明。声明分为三种类型：注册声明、公开声明和私有声明。例如：`{ "sub": "1234567890", "name": "John Doe", "iat": 1516239022 }`。这个部分也会被 Base64Url 编码。
3. 签名（Signature）：对头部和载荷进行签名，以确保令牌在传输过程中没有被篡改。签名是使用指定的哈希算法和一个密钥计算得出的。例如：`HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)`。

**工作原理**

1. 用户登录：当用户成功登录系统时，服务器会生成一个 JWT，并将其返回给客户端。
2. 客户端存储：客户端通常会将 JWT 存储在本地存储（如浏览器的 localStorage）或 Cookie 中。
3. 请求授权资源：在后续的请求中，客户端会在请求头中携带 JWT，通常使用 “Authorization” 头，格式为 “Bearer <token>”。
4. 服务器验证：服务器接收到请求后，会验证 JWT 的有效性。如果 JWT 有效，服务器会授权访问请求的资源；如果 JWT 无效，服务器会返回错误响应。

**优势**

1. 无状态：服务器不需要存储会话信息，因为所有的必要信息都包含在 JWT 中。这使得服务器可以轻松地扩展和处理大量的并发请求。
2. 安全性：JWT 可以使用数字签名来确保完整性和真实性。只有拥有正确密钥的服务器才能生成和验证 JWT。
3. 跨域资源共享（CORS）：由于 JWT 是通过请求头传递的，它可以在不同域之间的请求中使用，而不需要处理复杂的 CORS 配置。
4. 灵活性：可以在 JWT 的载荷中包含各种自定义的声明，以满足不同的应用需求。

**JWT使用**

引入依赖

导入错误。。。

#### 获取用户详细信息

#### 更新用户基本信息

#### 更新用户头像

#### 更新用户密码